#!/bin/bash
# =============================================================================
# EJECUTOR COMPLETO DE MIGRACI√ìN ERP
# SQL Server ‚Üí PostgreSQL (559 tablas)
# =============================================================================

echo "üöÄ INICIANDO MIGRACI√ìN COMPLETA ERP"
echo "üìä Sistema: 559 tablas, 9,964 campos documentados"
echo "üéØ Objetivo: Schema completo PostgreSQL + migraci√≥n datos"
echo "============================================================================="

# Variables de configuraci√≥n
TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
LOG_FILE="migration_complete_${TIMESTAMP}.log"
SCHEMA_FILE="complete_erp_schema_${TIMESTAMP}.sql"
DATA_LOG="data_migration_${TIMESTAMP}.log"

# Funci√≥n de logging
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a $LOG_FILE
}

# Verificar dependencias
check_dependencies() {
    log "üîç Verificando dependencias..."
    
    # Python y librer√≠as
    if ! command -v python3 &> /dev/null; then
        log "‚ùå Python3 no encontrado"
        exit 1
    fi
    
    # Docker
    if ! command -v docker &> /dev/null; then
        log "‚ùå Docker no encontrado"
        exit 1
    fi
    
    # Verificar contenedores
    if ! docker ps | grep -q "postgres-erp-migration"; then
        log "‚ùå Contenedor PostgreSQL no est√° corriendo"
        log "üí° Ejecutar: docker-compose up -d"
        exit 1
    fi
    
    if ! docker ps | grep -q "sqlserver-erp-origen"; then
        log "‚ùå Contenedor SQL Server no est√° corriendo"
        log "üí° Ejecutar: docker-compose up -d"
        exit 1
    fi
    
    log "‚úÖ Todas las dependencias verificadas"
}

# Fase 1: Generar schema completo
generate_complete_schema() {
    log "üèóÔ∏è  FASE 1: Generando schema completo (559 tablas)"
    
    python3 migration/generate_complete_schema.py > schema_generation.log 2>&1
    
    if [ $? -eq 0 ]; then
        log "‚úÖ Schema completo generado exitosamente"
        # El archivo se genera autom√°ticamente por el script Python
        GENERATED_SCHEMA=$(ls complete_schema_*.sql 2>/dev/null | head -1)
        if [ -n "$GENERATED_SCHEMA" ]; then
            log "üìÑ Archivo generado: $GENERATED_SCHEMA"
            SCHEMA_FILE=$GENERATED_SCHEMA
        fi
    else
        log "‚ùå Error generando schema completo"
        log "üìã Revisar: schema_generation.log"
        exit 1
    fi
}

# Fase 2: Ejecutar schema en PostgreSQL
execute_schema() {
    log "üìã FASE 2: Ejecutando schema en PostgreSQL"
    
    # Conectar a PostgreSQL y ejecutar schema
    docker exec -i postgres-erp-migration psql -U postgres -d erp_consolidasoft < $SCHEMA_FILE > schema_execution.log 2>&1
    
    if [ $? -eq 0 ]; then
        log "‚úÖ Schema ejecutado exitosamente en PostgreSQL"
        
        # Verificar cantidad de tablas creadas
        TABLE_COUNT=$(docker exec postgres-erp-migration psql -U postgres -d erp_consolidasoft -t -c "SELECT COUNT(*) FROM pg_tables WHERE schemaname = 'erp_main';" | tr -d ' ')
        log "üìä Tablas creadas en erp_main: $TABLE_COUNT"
        
        if [ "$TABLE_COUNT" -gt 500 ]; then
            log "üéâ Schema completo creado exitosamente"
        else
            log "‚ö†Ô∏è  Advertencia: Solo $TABLE_COUNT tablas creadas (esperadas ~559)"
        fi
    else
        log "‚ùå Error ejecutando schema en PostgreSQL"
        log "üìã Revisar: schema_execution.log"
        exit 1
    fi
}

# Fase 3: Validar estructura
validate_schema() {
    log "üîç FASE 3: Validando estructura creada"
    
    # Queries de validaci√≥n
    VALIDATION_SQL="
    -- Contar tablas por schema
    SELECT 'erp_main' as schema, COUNT(*) as tablas FROM pg_tables WHERE schemaname = 'erp_main'
    UNION ALL
    SELECT 'erp_control', COUNT(*) FROM pg_tables WHERE schemaname = 'erp_control';
    
    -- Contar secuencias
    SELECT 'sequences' as tipo, COUNT(*) as total FROM pg_sequences WHERE schemaname = 'erp_main';
    
    -- Contar foreign keys
    SELECT 'foreign_keys' as tipo, COUNT(*) as total 
    FROM information_schema.table_constraints 
    WHERE constraint_type = 'FOREIGN KEY' AND table_schema = 'erp_main';
    
    -- Contar √≠ndices
    SELECT 'indexes' as tipo, COUNT(*) as total 
    FROM pg_indexes WHERE schemaname = 'erp_main';
    "
    
    echo "$VALIDATION_SQL" | docker exec -i postgres-erp-migration psql -U postgres -d erp_consolidasoft > validation_results.log 2>&1
    
    if [ $? -eq 0 ]; then
        log "‚úÖ Validaci√≥n de estructura completada"
        log "üìä Resultados guardados en: validation_results.log"
        cat validation_results.log | tail -20 >> $LOG_FILE
    else
        log "‚ùå Error en validaci√≥n de estructura"
    fi
}

# Fase 4: Migraci√≥n de datos (opcional)
migrate_data() {
    log "üì¶ FASE 4: ¬øMigrar datos ahora? (s/N)"
    read -r MIGRATE_DATA
    
    if [[ $MIGRATE_DATA =~ ^[Ss]$ ]]; then
        log "üöÄ Iniciando migraci√≥n de datos..."
        
        python3 migration/migrate_erp_data.py > $DATA_LOG 2>&1 &
        MIGRATION_PID=$!
        
        log "üìà Migraci√≥n de datos ejecut√°ndose en background (PID: $MIGRATION_PID)"
        log "üìã Monitorear progreso: tail -f $DATA_LOG"
        log "üîç Estado en PostgreSQL: SELECT * FROM erp_control.migration_status ORDER BY start_time DESC;"
        
        # Opci√≥n de esperar o continuar
        log "üí° Presionar ENTER para esperar completaci√≥n, o Ctrl+C para continuar en background"
        read -r
        
        wait $MIGRATION_PID
        if [ $? -eq 0 ]; then
            log "üéâ Migraci√≥n de datos completada exitosamente"
        else
            log "‚ùå Migraci√≥n de datos fall√≥ - revisar $DATA_LOG"
        fi
    else
        log "‚è≠Ô∏è  Migraci√≥n de datos omitida"
        log "üí° Para migrar datos m√°s tarde: python3 migration/migrate_erp_data.py"
    fi
}

# Funci√≥n de reporte final
generate_report() {
    log "üìã GENERANDO REPORTE FINAL"
    
    REPORT_FILE="migration_report_${TIMESTAMP}.md"
    
    cat > $REPORT_FILE << EOF
# Reporte de Migraci√≥n ERP - $(date)

## Resumen Ejecutivo
- **Fecha:** $(date '+%Y-%m-%d %H:%M:%S')
- **Duraci√≥n total:** \$(($(date +%s) - START_TIME)) segundos
- **Archivos generados:** 
  - Schema: $SCHEMA_FILE
  - Logs: $LOG_FILE
  - Validaci√≥n: validation_results.log

## M√©tricas de Migraci√≥n
\`\`\`sql
-- Ejecutar en PostgreSQL para verificar estado
SELECT 
    'Tablas creadas' as metrica,
    COUNT(*) as valor
FROM pg_tables 
WHERE schemaname = 'erp_main'

UNION ALL SELECT 
    'Secuencias creadas',
    COUNT(*)
FROM pg_sequences 
WHERE schemaname = 'erp_main'

UNION ALL SELECT 
    'Foreign Keys',
    COUNT(*)
FROM information_schema.table_constraints 
WHERE constraint_type = 'FOREIGN KEY' 
  AND table_schema = 'erp_main'

UNION ALL SELECT 
    '√çndices creados',
    COUNT(*)
FROM pg_indexes 
WHERE schemaname = 'erp_main';
\`\`\`

## Estado de Migraci√≥n de Datos
\`\`\`sql
-- Progreso por tabla
SELECT 
    table_name,
    status,
    records_migrated,
    CASE status
        WHEN 'COMPLETED' THEN '‚úÖ'
        WHEN 'RUNNING' THEN 'üîÑ'
        WHEN 'FAILED' THEN '‚ùå'
        ELSE '‚è≥'
    END as status_icon,
    start_time,
    end_time
FROM erp_control.migration_status
ORDER BY start_time DESC
LIMIT 20;
\`\`\`

## Pr√≥ximos Pasos

### Si el Schema fue Exitoso:
1. **Validar tipos cr√≠ticos:**
   \`\`\`sql
   -- Verificar conversiones NUMERIC ‚Üí DECIMAL
   SELECT table_name, column_name, data_type, numeric_precision, numeric_scale
   FROM information_schema.columns 
   WHERE table_schema = 'erp_main' 
     AND data_type = 'numeric'
   ORDER BY table_name, column_name;
   \`\`\`

2. **Verificar campos BIGINT cr√≠ticos:**
   \`\`\`sql
   -- Verificar campos transaccionales ‚Üí BIGINT
   SELECT table_name, column_name, data_type
   FROM information_schema.columns 
   WHERE table_schema = 'erp_main' 
     AND data_type = 'bigint'
     AND (table_name LIKE '%factura%' 
          OR table_name LIKE '%pedido%' 
          OR table_name LIKE '%venta%')
   ORDER BY table_name, column_name;
   \`\`\`

3. **Ejecutar migraci√≥n de datos:**
   \`\`\`bash
   python3 migration/migrate_erp_data.py
   \`\`\`

### Si Hay Errores:
1. **Revisar logs:** $LOG_FILE
2. **Verificar conexiones:** docker-compose ps
3. **Validar estructura SQL Server:** Verificar que todas las 559 tablas est√©n accesibles

## Archivos de Referencia
- **Schema generado:** $SCHEMA_FILE
- **Log principal:** $LOG_FILE  
- **Validaci√≥n:** validation_results.log
- **Datos (si aplica):** $DATA_LOG

## Comandos de Verificaci√≥n
\`\`\`bash
# Ver tablas creadas
docker exec postgres-erp-migration psql -U postgres -d erp_consolidasoft -c "\\dt erp_main.*"

# Ver progreso de migraci√≥n
docker exec postgres-erp-migration psql -U postgres -d erp_consolidasoft -c "SELECT * FROM erp_control.migration_status ORDER BY created_at DESC LIMIT 10;"

# Conectar directamente a PostgreSQL
docker exec -it postgres-erp-migration psql -U postgres -d erp_consolidasoft

# Conectar directamente a SQL Server
docker exec -it sqlserver-erp-origen /opt/mssql-tools18/bin/sqlcmd -S localhost -U sa -P "MigracionERP2025!" -C
\`\`\`

---
**Generado autom√°ticamente por el sistema de migraci√≥n ERP**
EOF
    
    log "üìÑ Reporte generado: $REPORT_FILE"
}

# Funci√≥n de cleanup
cleanup() {
    log "üßπ Limpieza de archivos temporales..."
    # Mantener archivos importantes, limpiar temporales
    rm -f schema_generation.log schema_execution.log 2>/dev/null
    log "‚úÖ Limpieza completada"
}

# Funci√≥n principal
main() {
    START_TIME=$(date +%s)
    log "üöÄ INICIANDO PROCESO COMPLETO DE MIGRACI√ìN ERP"
    log "‚è∞ Hora de inicio: $(date)"
    
    # Ejecutar fases secuenciales
    check_dependencies
    generate_complete_schema
    execute_schema
    validate_schema
    migrate_data
    generate_report
    cleanup
    
    END_TIME=$(date +%s)
    DURATION=$((END_TIME - START_TIME))
    
    log "üéâ PROCESO COMPLETO FINALIZADO"
    log "‚è±Ô∏è  Duraci√≥n total: ${DURATION} segundos"
    log "üìã Reporte final: migration_report_${TIMESTAMP}.md"
    log "üìä Para verificar estado: docker exec -it postgres-erp-migration psql -U postgres -d erp_consolidasoft"
}

# Manejo de interrupciones
trap 'log "‚ö†Ô∏è  Proceso interrumpido por usuario"; exit 1' INT

# Verificar si se ejecuta directamente
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi